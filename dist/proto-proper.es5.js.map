{"version":3,"sources":["proto-proper.js"],"names":["Proto","Object","create","prototype","assign","newPrototype","new","newInstance","init","arguments","instanceOf","proto","thisProto","getPrototypeOf"],"mappings":";;;;;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,IAAIA,QAAQC,OAAOC,MAAP,CAAcD,OAAOE,SAArB,CAAZ;;AAIAF,OAAOG,MAAP,CAAcJ,KAAd,EAAqB;;AAEnB;;;;AAIAK,cANmB,0BAMJ;AACb,WAAOJ,OAAOC,MAAP,CAAc,IAAd,CAAP;AACD,GARkB;;;AAWnB;;;;;;;;;;;;;AAaAI,KAxBmB,kBAwBb;AACJ,QAAIC,cAAcN,OAAOC,MAAP,CAAc,IAAd,CAAlB;;AAEAK,gBAAYC,IAAZ,oBAAoBC,SAApB;;AAEA,WAAOF,WAAP;AACD,GA9BkB;;;AAkCnB;;;;;;AAMAC,MAxCmB,kBAwCZ;AACL;AACD,GA1CkB;;;AA6CnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCAE,YApFmB,sBAoFRC,KApFQ,EAoFD;AAChB,QAAIA,UAAU,IAAV,IAAkBA,UAAUX,KAA5B,IAAqCW,UAAUV,OAAOE,SAA1D,EAAqE;AACnE,aAAO,IAAP;AACD;;AAED,QAAIS,YAAYX,OAAOY,cAAP,CAAsB,IAAtB,CAAhB;;AAEA,QAAID,aAAa,IAAjB,EAAuB;AACrB,aAAO,KAAP;AACD;;AAED,WAAQA,cAAcD,KAAd,IACMC,UAAUF,UAAV,IAAwB,IAAxB,IAAgCE,UAAUF,UAAV,CAAqBC,KAArB,CAD9C;AAED;AAjGkB,CAArB;;kBAsGeX,K","file":"proto-proper.es5.js","sourcesContent":["// eslint-disable-next-line spaced-comment\n/**!\n * proto-proper.js (1.0.0)\n *\n * ISC License (ISC)\n *\n * Copyright (c) 2017 Brandon Sara (http://bsara.github.io/)\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n\n\n/**\n * A generic prototype upon which new prototypes can be based.\n *\n * This object contains functions useful for prototype creation, manipulation,\n * inheritance, and for obtaining useful information about a prototype.\n *\n * @type {Object}\n * @extends {Object.prototype}\n *\n *\n * @example\n * // Creating a New Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n *\n * @example\n * // Inheritance From a Custom Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n * let MyChildObject = MyObject.newPrototype();\n *\n * MyChildObject.init = function(options) { ... };\n *\n *\n * @example\n * // Object Instantiation\n * let obj = MyObject.new( ... );\n */\nlet Proto = Object.create(Object.prototype);\n\n\n\nObject.assign(Proto, {\n\n  /**\n   * TODO: Add description\n   * @returns TODO: Add description\n   */\n  newPrototype() {\n    return Object.create(this);\n  },\n\n\n  /**\n   * Creates a new instance of this prototype.\n   *\n   * This function is to be called **instead of** using the `new` keyword.\n   *\n   * Any arguments passed to this function will be used as the\n   * arguments for the call made to the `init` function.\n   *\n   * @example\n   * let obj = MyObject.new();\n   *\n   * @returns A newly created and initialized instance of this prototype.\n   */\n  new() {\n    let newInstance = Object.create(this);\n\n    newInstance.init(...arguments);\n\n    return newInstance;\n  },\n\n\n\n  /**\n   * Initializes object.\n   *\n   * This function is called whenever `new` is called and can be seen as\n   * the \"constructor\" of the prototype.\n   */\n  init() {\n    // Intentionally doing nothing\n  },\n\n\n  /**\n   * @param {Object} proto - TODO: Add description\n   *\n   * @example\n   * let Parent = Proto.newPrototype();\n   * let Child  = Parent.newPrototype();\n   *\n   * let parentObj = Parent.new();\n   * let childObj  = Child.new();\n   *\n   * Parent.instanceOf(Object); // returns `false`\n   * Child.instanceOf(Object);  // returns `false`\n   *\n   * parentObj.instanceOf(Object); // returns `false`\n   * childObj.instanceOf(Object);  // returns `false`\n   *\n   * Parent.instanceOf(Parent);           // returns `true`\n   * Parent.instanceOf(Proto);            // returns `true`\n   * Parent.instanceOf(Object.prototype); // returns `true`\n   *\n   * Child.instanceOf(Child);            // returns `true`\n   * Child.instanceOf(Parent);           // returns `true`\n   * Child.instanceOf(Proto);            // returns `true`\n   * Child.instanceOf(Object.prototype); // returns `true`\n   *\n   * parentObj.instanceOf(parentObj);        // returns `true`\n   * parentObj.instanceOf(Parent);           // returns `true`\n   * parentObj.instanceOf(Proto);            // returns `true`\n   * parentObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * childObj.instanceOf(childObj);         // returns `true`\n   * childObj.instanceOf(Child);            // returns `true`\n   * childObj.instanceOf(Parent);           // returns `true`\n   * childObj.instanceOf(Proto);            // returns `true`\n   * childObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * @returns {Boolean} `true` if the given `proto` is found in the prototype\n   *                    chain of this object; otherwise, returns `false`.\n   */\n  instanceOf(proto) {\n    if (proto === this || proto === Proto || proto === Object.prototype) {\n      return true;\n    }\n\n    let thisProto = Object.getPrototypeOf(this);\n\n    if (thisProto == null) {\n      return false;\n    }\n\n    return (thisProto === proto\n              || (thisProto.instanceOf != null && thisProto.instanceOf(proto)));\n  }\n});\n\n\n\nexport default Proto;\n"]}