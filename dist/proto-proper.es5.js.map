{"version":3,"sources":["proto-proper.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA,IAAI,QAAQ,OAAO,MAAP,CAAc,OAAO,SAArB,CAAZ;;AAIA,OAAO,MAAP,CAAc,KAAd,EAAqB;;;;;;;AAMnB,cANmB,0BAMJ;AACb,WAAO,OAAO,MAAP,CAAc,IAAd,CAAP;AACD,GARkB;;;;;;;;;;;;;;;;AAwBnB,KAxBmB,kBAwBb;AACJ,QAAI,cAAc,OAAO,MAAP,CAAc,IAAd,CAAlB;;AAEA,gBAAY,IAAZ,oBAAoB,SAApB;;AAEA,WAAO,WAAP;AACD,GA9BkB;;;;;;;;;AAwCnB,MAxCmB,kBAwCZ;;AAEN,GA1CkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFnB,YApFmB,sBAoFR,KApFQ,EAoFD;AAChB,QAAI,UAAU,IAAV,IAAkB,UAAU,KAA5B,IAAqC,UAAU,OAAO,SAA1D,EAAqE;AACnE,aAAO,IAAP;AACD;;AAED,QAAI,YAAY,OAAO,cAAP,CAAsB,IAAtB,CAAhB;;AAEA,QAAI,aAAa,IAAjB,EAAuB;AACrB,aAAO,KAAP;AACD;;AAED,WAAQ,cAAc,KAAd,IACM,UAAU,UAAV,IAAwB,IAAxB,IAAgC,UAAU,UAAV,CAAqB,KAArB,CAD9C;AAED;AAjGkB,CAArB;;kBAsGe,K","file":"proto-proper.es5.js","sourcesContent":["/*!\n * proto-proper.js (1.0.0-beta.0)\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2016 Brandon Sara (http://bsara.github.io/)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n/**\n * A generic prototype upon which new prototypes can be based.\n *\n * This object contains functions useful for prototype creation, manipulation,\n * inheritance, and for obtaining useful information about a prototype.\n *\n * @type {Object}\n * @extends {Object.prototype}\n *\n *\n * @example\n * // Creating a New Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n *\n * @example\n * // Inheritance From a Custom Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n * let MyChildObject = MyObject.newPrototype();\n *\n * MyChildObject.init = function(options) { ... };\n *\n *\n * @example\n * // Object Instantiation\n * let obj = MyObject.new( ... );\n */\nlet Proto = Object.create(Object.prototype);\n\n\n\nObject.assign(Proto, {\n\n  /**\n   * TODO: Add description\n   * @returns TODO: Add description\n   */\n  newPrototype() {\n    return Object.create(this);\n  },\n\n\n  /**\n   * Creates a new instance of this prototype.\n   *\n   * This function is to be called **instead of** using the `new` keyword.\n   *\n   * Any arguments passed to this function will be used as the\n   * arguments for the call made to the `init` function.\n   *\n   * @example\n   * let obj = MyObject.new();\n   *\n   * @returns A newly created and initialized instance of this prototype.\n   */\n  new() {\n    let newInstance = Object.create(this);\n\n    newInstance.init(...arguments);\n\n    return newInstance;\n  },\n\n\n\n  /**\n   * Initializes object.\n   *\n   * This function is called whenever `new` is called and can be seen as\n   * the \"constructor\" of the prototype.\n   */\n  init() {\n    // Intentionally doing nothing\n  },\n\n\n  /**\n   * @param {Object} proto - TODO: Add description\n   *\n   * @example\n   * let Parent = Proto.newPrototype();\n   * let Child  = Parent.newPrototype();\n   *\n   * let parentObj = Parent.new();\n   * let childObj  = Child.new();\n   *\n   * Parent.instanceOf(Object); // returns `false`\n   * Child.instanceOf(Object);  // returns `false`\n   *\n   * parentObj.instanceOf(Object); // returns `false`\n   * childObj.instanceOf(Object);  // returns `false`\n   *\n   * Parent.instanceOf(Parent);           // returns `true`\n   * Parent.instanceOf(Proto);            // returns `true`\n   * Parent.instanceOf(Object.prototype); // returns `true`\n   *\n   * Child.instanceOf(Child);            // returns `true`\n   * Child.instanceOf(Parent);           // returns `true`\n   * Child.instanceOf(Proto);            // returns `true`\n   * Child.instanceOf(Object.prototype); // returns `true`\n   *\n   * parentObj.instanceOf(parentObj);        // returns `true`\n   * parentObj.instanceOf(Parent);           // returns `true`\n   * parentObj.instanceOf(Proto);            // returns `true`\n   * parentObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * childObj.instanceOf(childObj);         // returns `true`\n   * childObj.instanceOf(Child);            // returns `true`\n   * childObj.instanceOf(Parent);           // returns `true`\n   * childObj.instanceOf(Proto);            // returns `true`\n   * childObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * @returns {Boolean} `true` if the given `proto` is found in the prototype\n   *                    chain of this object; otherwise, returns `false`.\n   */\n  instanceOf(proto) {\n    if (proto === this || proto === Proto || proto === Object.prototype) {\n      return true;\n    }\n\n    let thisProto = Object.getPrototypeOf(this);\n\n    if (thisProto == null) {\n      return false;\n    }\n\n    return (thisProto === proto\n              || (thisProto.instanceOf != null && thisProto.instanceOf(proto)));\n  }\n});\n\n\n\nexport default Proto;\n"]}