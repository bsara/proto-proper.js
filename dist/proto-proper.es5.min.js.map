{"version":3,"sources":["proto-proper.es5.js","proto-proper.js"],"names":["root","factory","define","amd","exports","module","require","Proto","undefined","this","Object","defineProperty","value","create","prototype","assign","newPrototype","new","newInstance","init","apply","arguments","instanceOf","proto","thisProto","getPrototypeOf"],"mappings":"CAyBE,SAASA,EAAMC,GACf,MAAsB,kBAAXC,SAAyBA,OAAOC,QACzCD,QAAOD,GAGc,gBAAZG,cACTC,OAAOD,QAAUH,EAAQK,QAASF,QAASC,cAG7CL,EAAKO,MAAQN,EAAQO,UAAeA,UACpCC,KAAM,SAASH,EAASF,EAASC,GACnC,YAEAK,QAAOC,eAAeP,EAAS,cAC7BQ,OAAO,GCqCN,IARkBL,GAAAG,OAAAG,OAAAH,OAAAI,UD+GrB,OAnGAJ,QAAOK,OAAOR,GAOZS,aAAc,WACZ,MAAON,QAAOG,OAAOJ,OAiBvBQ,MAAK,WACH,GAAIC,GAAcR,OAAOG,OAAOJ,KAIhC,OAFAS,GAAYC,KAAKC,MAAMF,EAAaG,WAE7BH,GAUTC,KAAM,aC2CJG,WAAQ,SACMC,GACf,GAAAA,IAAAd,MAAAc,IAAAhB,GAAAgB,IAAAb,OAAAI,UAjGH,OAAA,CDqGI,IAAIU,GAAYd,OAAOe,eAAehB,KAEtC,OAAiB,OAAbe,GACK,EAGFA,IAAcD,GAAiC,MAAxBC,EAAUF,YAAsBE,EAAUF,WAAWC,MAIhFnB,EAAAA,WAAkBG","file":"proto-proper.es5.min.js","sourcesContent":["/*!\n * proto-proper.js (1.0.0-beta.9)\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2016 Brandon Sara (http://bsara.github.io/)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n    return;\n  }\n  if (typeof exports === 'object') {\n    module.exports = factory(require, exports, module);\n    return;\n  }\n  root.Proto = factory(undefined, {}, undefined);\n}(this, function(require, exports, module) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * A generic prototype upon which new prototypes can be based.\n *\n * This object contains functions useful for prototype creation, manipulation,\n * inheritance, and for obtaining useful information about a prototype.\n *\n * @type {Object}\n * @extends {Object.prototype}\n *\n *\n * @example\n * // Creating a New Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n *\n * @example\n * // Inheritance From a Custom Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n * let MyChildObject = MyObject.newPrototype();\n *\n * MyChildObject.init = function(options) { ... };\n *\n *\n * @example\n * // Object Instantiation\n * let obj = MyObject.new( ... );\n */\nvar Proto = Object.create(Object.prototype);\n\nObject.assign(Proto, {\n\n  /**\n   * TODO: Add description\n   * @returns TODO: Add description\n   */\n\n  newPrototype: function newPrototype() {\n    return Object.create(this);\n  },\n\n\n  /**\n   * Creates a new instance of this prototype.\n   *\n   * This function is to be called **instead of** using the `new` keyword.\n   *\n   * Any arguments passed to this function will be used as the\n   * arguments for the call made to the `init` function.\n   *\n   * @example\n   * let obj = MyObject.new();\n   *\n   * @returns A newly created and initialized instance of this prototype.\n   */\n  new: function _new() {\n    var newInstance = Object.create(this);\n\n    newInstance.init.apply(newInstance, arguments);\n\n    return newInstance;\n  },\n\n\n  /**\n   * Initializes object.\n   *\n   * This function is called whenever `new` is called and can be seen as\n   * the \"constructor\" of the prototype.\n   */\n  init: function init() {\n    // Intentionally doing nothing\n  },\n\n\n  /**\n   * @param {Object} proto - TODO: Add description\n   *\n   * @example\n   * let Parent = Proto.newPrototype();\n   * let Child  = Parent.newPrototype();\n   *\n   * let parentObj = Parent.new();\n   * let childObj  = Child.new();\n   *\n   * Parent.instanceOf(Object); // returns `false`\n   * Child.instanceOf(Object);  // returns `false`\n   *\n   * parentObj.instanceOf(Object); // returns `false`\n   * childObj.instanceOf(Object);  // returns `false`\n   *\n   * Parent.instanceOf(Parent);           // returns `true`\n   * Parent.instanceOf(Proto);            // returns `true`\n   * Parent.instanceOf(Object.prototype); // returns `true`\n   *\n   * Child.instanceOf(Child);            // returns `true`\n   * Child.instanceOf(Parent);           // returns `true`\n   * Child.instanceOf(Proto);            // returns `true`\n   * Child.instanceOf(Object.prototype); // returns `true`\n   *\n   * parentObj.instanceOf(parentObj);        // returns `true`\n   * parentObj.instanceOf(Parent);           // returns `true`\n   * parentObj.instanceOf(Proto);            // returns `true`\n   * parentObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * childObj.instanceOf(childObj);         // returns `true`\n   * childObj.instanceOf(Child);            // returns `true`\n   * childObj.instanceOf(Parent);           // returns `true`\n   * childObj.instanceOf(Proto);            // returns `true`\n   * childObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * @returns {Boolean} `true` if the given `proto` is found in the prototype\n   *                    chain of this object; otherwise, returns `false`.\n   */\n  instanceOf: function instanceOf(proto) {\n    if (proto === this || proto === Proto || proto === Object.prototype) {\n      return true;\n    }\n\n    var thisProto = Object.getPrototypeOf(this);\n\n    if (thisProto == null) {\n      return false;\n    }\n\n    return thisProto === proto || thisProto.instanceOf != null && thisProto.instanceOf(proto);\n  }\n});\n\nreturn exports.default = Proto;\n}));\n\n//# sourceMappingURL=proto-proper.es5.js.map\n","/*!\n * proto-proper.js (1.0.0-beta.9)\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2016 Brandon Sara (http://bsara.github.io/)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n\n\n/**\n * A generic prototype upon which new prototypes can be based.\n *\n * This object contains functions useful for prototype creation, manipulation,\n * inheritance, and for obtaining useful information about a prototype.\n *\n * @type {Object}\n * @extends {Object.prototype}\n *\n *\n * @example\n * // Creating a New Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n *\n * @example\n * // Inheritance From a Custom Prototype\n *\n * let MyObject = Proto.newPrototype();\n *\n * MyObject.init = function(options) { ... };\n * MyObject.func0 = function() { ... };\n *\n * let MyChildObject = MyObject.newPrototype();\n *\n * MyChildObject.init = function(options) { ... };\n *\n *\n * @example\n * // Object Instantiation\n * let obj = MyObject.new( ... );\n */\nlet Proto = Object.create(Object.prototype);\n\n\n\nObject.assign(Proto, {\n\n  /**\n   * TODO: Add description\n   * @returns TODO: Add description\n   */\n  newPrototype() {\n    return Object.create(this);\n  },\n\n\n  /**\n   * Creates a new instance of this prototype.\n   *\n   * This function is to be called **instead of** using the `new` keyword.\n   *\n   * Any arguments passed to this function will be used as the\n   * arguments for the call made to the `init` function.\n   *\n   * @example\n   * let obj = MyObject.new();\n   *\n   * @returns A newly created and initialized instance of this prototype.\n   */\n  new() {\n    let newInstance = Object.create(this);\n\n    newInstance.init(...arguments);\n\n    return newInstance;\n  },\n\n\n\n  /**\n   * Initializes object.\n   *\n   * This function is called whenever `new` is called and can be seen as\n   * the \"constructor\" of the prototype.\n   */\n  init() {\n    // Intentionally doing nothing\n  },\n\n\n  /**\n   * @param {Object} proto - TODO: Add description\n   *\n   * @example\n   * let Parent = Proto.newPrototype();\n   * let Child  = Parent.newPrototype();\n   *\n   * let parentObj = Parent.new();\n   * let childObj  = Child.new();\n   *\n   * Parent.instanceOf(Object); // returns `false`\n   * Child.instanceOf(Object);  // returns `false`\n   *\n   * parentObj.instanceOf(Object); // returns `false`\n   * childObj.instanceOf(Object);  // returns `false`\n   *\n   * Parent.instanceOf(Parent);           // returns `true`\n   * Parent.instanceOf(Proto);            // returns `true`\n   * Parent.instanceOf(Object.prototype); // returns `true`\n   *\n   * Child.instanceOf(Child);            // returns `true`\n   * Child.instanceOf(Parent);           // returns `true`\n   * Child.instanceOf(Proto);            // returns `true`\n   * Child.instanceOf(Object.prototype); // returns `true`\n   *\n   * parentObj.instanceOf(parentObj);        // returns `true`\n   * parentObj.instanceOf(Parent);           // returns `true`\n   * parentObj.instanceOf(Proto);            // returns `true`\n   * parentObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * childObj.instanceOf(childObj);         // returns `true`\n   * childObj.instanceOf(Child);            // returns `true`\n   * childObj.instanceOf(Parent);           // returns `true`\n   * childObj.instanceOf(Proto);            // returns `true`\n   * childObj.instanceOf(Object.prototype); // returns `true`\n   *\n   * @returns {Boolean} `true` if the given `proto` is found in the prototype\n   *                    chain of this object; otherwise, returns `false`.\n   */\n  instanceOf(proto) {\n    if (proto === this || proto === Proto || proto === Object.prototype) {\n      return true;\n    }\n\n    let thisProto = Object.getPrototypeOf(this);\n\n    if (thisProto == null) {\n      return false;\n    }\n\n    return (thisProto === proto\n              || (thisProto.instanceOf != null && thisProto.instanceOf(proto)));\n  }\n});\n\n\n\nexport default Proto;\n"]}